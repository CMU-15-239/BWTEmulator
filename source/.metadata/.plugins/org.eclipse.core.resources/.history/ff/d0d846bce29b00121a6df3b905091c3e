package edu.cmu.scripting;

import java.util.List;
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.StringTokenizer;

public class ScriptParser {

	public static final String SUCCESS = "Success";
	public static final String ERROR = "Error";
	
	public static final int STATUS_KEY = 0;
	public static final int MESSAGE_KEY = 1;

	private static final char COMMENT_SIGN = '#';
	private static final String WAIT_COMMAND = "wait";
	private static final List<String> ACTION_COMMANDS = new ArrayList<String>(
			Arrays.asList(new String[]{"click","hold_down","release"})
	);

	private static final int WAIT_MIN = 50;
	private static final int WAIT_MAX = 10000;
	
	public static Map<Integer, String> parseScript(String scriptName){
		Map<Integer, String> result = new HashMap<Integer,String>();
		List<String> heldDown = new ArrayList<String>();
		
		List<String> errors = new ArrayList<String>();

		//a flag to tell whether to insert automatic wait() between 
		//consecutive button presses
		boolean isButtonCommand = false;
		int lineNumber = 0;
		try {
			BufferedReader reader = new BufferedReader(new FileReader(scriptName));
			String line;
			while((line = reader.readLine()) != null ){
				line = line.trim();
				if(line.charAt(0) != COMMENT_SIGN){			
					StringTokenizer st = new StringTokenizer(scriptName, " \t\n");
					int count = st.countTokens();
					if(count<2){
						errors.add(prepareErrorMessage(lineNumber,"Too few arguments"));
					}
					else if(count > 2){
						errors.add(prepareErrorMessage(lineNumber,"Too many arguments"));
					}
					else{
						String action = st.nextToken().toLowerCase();
						String argument = st.nextToken().toLowerCase();
						if(isWaitCommand(action)){
							int milliSeconds =0;
							try{
								milliSeconds = Integer.parseInt(argument);
							}
							catch(NumberFormatException e){
								errors.add(prepareErrorMessage(lineNumber, 
										"Invalid argument for wait. Must be an integer between " + 
										WAIT_MIN +" and " + WAIT_MAX));
							}
							if(milliSeconds> WAIT_MAX || milliSeconds < WAIT_MIN){
								
							}
							
						}
						else if(isButtonCommand(action)){
							
						}
						else{
							errors.add(prepareErrorMessage(lineNumber, "Unrecognized command: " + action));
							
						}
						
					}
				}
				lineNumber ++;
			}
			
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
		return result;
	}
	
	private static boolean isButtonCommand(String action){
		//TODO
		return action!=null && ACTION_COMMANDS.indexOf(action)!=-1; 
	}
	
	private static boolean isWaitCommand(String action){
		return action!=null && action.equals(WAIT_COMMAND); 
	}

	private static boolean isValidButtonCode(String argument){
		//TODO
		return false;
	}
	
	private static String prepareErrorMessage(int lineNumber, String message){
		return "Error: line "+ lineNumber+ ". " + message.trim();
	}
	
	
	
}
